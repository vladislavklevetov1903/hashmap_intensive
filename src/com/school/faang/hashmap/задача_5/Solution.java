package com.school.faang.hashmap.задача_5;


import java.util.HashMap;
import java.util.Map;

public class Solution {
    public static void main(String[] args) {

        String text = "Прежде всего следует упомянуть, что доклад посвящен способам использования Spring Data и Hibernate, ориентированным на производительность, так что речь в нем идет о старых добрых технологиях, которые используются уже примерно 15 лет. И главный вопрос, который он затрагивает: «Как сделать медленные приложения быстрее?».\n" +
                "\n" +
                "Прежде всего, необходимо уяснить, что мы вкладываем в понятие «медленное приложение». Обычно это выглядит так: кто‑то приходит и говорит, «Приложение нельзя использовать, оно медленное, загрузка занимает много времени, клиенты жалуются!» А разработчики, в свою очередь, прекрасно умеют находить оправдания практически для любой проблемы. 20 лет назад было принято говорить, что просто Java как таковая — это медленная среда разработки, потому что все, кто когда‑либо писал на Java, использовал ее на десктопе с Open Office или Eclipse, и при таком способе использования Java действительно была медленной.\n" +
                "\n" +
                "Сейчас это утверждение больше не является верным. Современная Java — довольно быстрая среда разработки, и мы больше не можем винить за то, что наше приложение медленно работает. Так что наш новый подозреваемый — это база данных. Поскольку у нас такой большой трафик, так много данных, очень легко сослаться на то, что базе данных недостает производительности. И это очень легко доказать, если у вас есть какой‑то способ мониторинга. Вы можете сказать, что ваша база данных достигла предела по CPU или I/O, а значит, надо просто раздобыть базу данных, которая больше удовлетворяет вашим требованиям. И дальше мы просто тратим еще несколько тысяч долларов на такую базу данных. В эру облачных технологий это не представляет никакой проблемы.\n" +
                "\n" +
                "Если же виновата не база данных, это может быть фреймворк. Потому что фреймворки, которые мы используем, супер-сложные, и, очевидно, они обязаны быть медленными. Но на самом деле чаще всего виновата не Java и не база данных. И даже не фреймворк. На самом деле, чаще всего проблема заключается в том, как именно мы используем все эти технологии. Именно наш подход определяет, будет ли приложение работать медленно или быстро. \n" +
                "\n" +
                "Чаще всего проблема обычно сводится к следующему: либо в приложении наблюдается плохое управление подключениями, и тогда приложение просто зависает и больше не может отвечать на запросы, либо приложение отправляет намного больше запросов, чем ему реально необходимо. Приложение также может отправлять очень медленные запросы, которые являются таковыми из-за отсутствия нормальных индексов. \n" +
                "\n" +
                "Избыточные запросы довольно часто бывают вызваны неправильным JPA маппингом, а также загрузкой большего количества данных, чем реально необходимо. \n" +
                "\n" +
                "Первое правило при исправлении любых проблем с производительностью состоит в том, чтобы не гадать на кофейной гуще, а использовать инструменты для мониторинга, чтобы наверняка понять, на какой стороне находится проблема с производительностью. Иначе может оказаться, что на тестовом стенде приложение покажет серьезное улучшение по производительности, а в продакшен будет работать медленнее, чем до всех исправлений. Существующие в наше время инструменты мониторинга позволяют достаточно точно понять, что именно происходит в приложении. При этом можно пользоваться распределенным отслеживанием  (distributed tracing) или отслеживать только один сервис. ";

        String resText = text.toLowerCase().replaceAll("[\\p{Punct}]", "");

        String[] strList = resText.split(" ");

        Map<String, Integer> map = new HashMap<>();

        for (String str : strList) {
            if (map.containsKey(str)) {
                map.put(str, map.get(str) + 1);
            } else {
                map.put(str, 1);
            }
        }

        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            if (entry.getValue() > 5) {
                System.out.println(entry.getKey() + " : " + entry.getValue());
            }
        }
    }

}
